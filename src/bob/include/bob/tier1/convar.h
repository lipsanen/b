#pragma once

#include <cstddef>
#include "bob/tier1/utlstring.h"
#include "bob/tier1/utlvector.h"

#define FORCEINLINE_CVAR inline

namespace bob
{
	//-----------------------------------------------------------------------------
	// Forward declarations
	//-----------------------------------------------------------------------------
	class ConVar;
	class CCommand;
	class ConCommand;
	class ConCommandBase;
	struct characterset_t;
	typedef int CVarDLLIdentifier_t;

	extern int s_nDLLIdentifier;

	//-----------------------------------------------------------------------------
	// ConVar flags
	//-----------------------------------------------------------------------------
	// The default, no flags at all
	#define FCVAR_NONE				0 

	// Command to ConVars and ConCommands
	// ConVar Systems
	#define FCVAR_UNREGISTERED		(1<<0)	// If this is set, don't add to linked list, etc.
	#define FCVAR_DEVELOPMENTONLY	(1<<1)	// Hidden in released products. Flag is removed automatically if ALLOW_DEVELOPMENT_CVARS is defined.
	#define FCVAR_GAMEDLL			(1<<2)	// defined by the game DLL
	#define FCVAR_CLIENTDLL			(1<<3)  // defined by the client DLL
	#define FCVAR_HIDDEN			(1<<4)	// Hidden. Doesn't appear in find or autocomplete. Like DEVELOPMENTONLY, but can't be compiled out.

	// ConVar only
	#define FCVAR_PROTECTED			(1<<5)  // It's a server cvar, but we don't send the data since it's a password, etc.  Sends 1 if it's not bland/zero, 0 otherwise as value
	#define FCVAR_SPONLY			(1<<6)  // This cvar cannot be changed by clients connected to a multiplayer server.
	#define	FCVAR_ARCHIVE			(1<<7)	// set to cause it to be saved to vars.rc
	#define	FCVAR_NOTIFY			(1<<8)	// notifies players when changed
	#define	FCVAR_USERINFO			(1<<9)	// changes the client's info string
	#define FCVAR_CHEAT				(1<<14) // Only useable in singleplayer / debug / multiplayer & sv_cheats

	#define FCVAR_PRINTABLEONLY		(1<<10)  // This cvar's string cannot contain unprintable characters ( e.g., used for player name etc ).
	#define FCVAR_UNLOGGED			(1<<11)  // If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log
	#define FCVAR_NEVER_AS_STRING	(1<<12)  // never try to print that cvar

	// It's a ConVar that's shared between the client and the server.
	// At signon, the values of all such ConVars are sent from the server to the client (skipped for local
	//  client, of course )
	// If a change is requested it must come from the console (i.e., no remote client changes)
	// If a value is changed while a server is active, it's replicated to all connected clients
	#define FCVAR_REPLICATED		(1<<13)	// server setting enforced on clients, TODO rename to FCAR_SERVER at some time
	#define FCVAR_DEMO				(1<<16)  // record this cvar when starting a demo file
	#define FCVAR_DONTRECORD		(1<<17)  // don't record these command in demofiles

	#define FCVAR_NOT_CONNECTED		(1<<22)	// cvar cannot be changed by a client that is connected to a server

	#define FCVAR_ARCHIVE_XBOX		(1<<24) // cvar written to config.cfg on the Xbox

	#define FCVAR_SERVER_CAN_EXECUTE	(1<<28)// the server is allowed to execute this command on clients via ClientCommand/NET_StringCmd/CBaseClientState::ProcessStringCmd.
	#define FCVAR_SERVER_CANNOT_QUERY	(1<<29)// If this is set, then the server is not allowed to query this cvar's value (via IServerPluginHelpers::StartQueryCvarValue).
	#define FCVAR_CLIENTCMD_CAN_EXECUTE	(1<<30)	// IVEngineClient::ClientCmd is allowed to execute this command. 
												// Note: IVEngineClient::ClientCmd_Unrestricted can run any client command.

	// #define FCVAR_AVAILABLE			(1<<15)
	// #define FCVAR_AVAILABLE			(1<<18)
	// #define FCVAR_AVAILABLE			(1<<19)
	// #define FCVAR_AVAILABLE			(1<<20)
	// #define FCVAR_AVAILABLE			(1<<21)
	// #define FCVAR_AVAILABLE			(1<<23)
	// #define FCVAR_AVAILABLE			(1<<25)
	// #define FCVAR_AVAILABLE			(1<<26)
	// #define FCVAR_AVAILABLE			(1<<27)
	// #define FCVAR_AVAILABLE			(1<<31)


	//-----------------------------------------------------------------------------
	// Called when a ConVar changes value
	// NOTE: For FCVAR_NEVER_AS_STRING ConVars, pOldValue == NULL
	//-----------------------------------------------------------------------------
	class IConVar;
	typedef void ( *FnChangeCallback_t )( IConVar *var, const char *pOldValue, float flOldValue );


	//-----------------------------------------------------------------------------
	// Abstract interface for ConVars
	//-----------------------------------------------------------------------------
	class IConVar
	{
	public:
		// Value set
		virtual void SetValue( const char *pValue ) = 0;
		virtual void SetValue( float flValue ) = 0;
		virtual void SetValue( int nValue ) = 0;

		// Return name of command
		virtual const char *GetName( void ) const = 0;

		// Accessors.. not as efficient as using GetState()/GetInfo()
		// if you call these methods multiple times on the same IConVar
		virtual bool IsFlagSet( int nFlag ) const = 0;
	};

	//-----------------------------------------------------------------------------
	// Any executable that wants to use ConVars need to implement one of
	// these to hook up access to console variables.
	//-----------------------------------------------------------------------------
	class IConCommandBaseAccessor
	{
	public:
		// Flags is a combination of FCVAR flags in cvar.h.
		// hOut is filled in with a handle to the variable.
		virtual bool RegisterConCommandBase( ConCommandBase *pVar ) = 0;
	};


	//-----------------------------------------------------------------------------
	// Helper method for console development
	//-----------------------------------------------------------------------------
	#if defined( _X360 ) && !defined( _RETAIL )
	void ConVar_PublishToVXConsole();
	#endif


	//-----------------------------------------------------------------------------
	// Called when a ConCommand needs to execute
	//-----------------------------------------------------------------------------
	typedef void ( *FnCommandCallbackV1_t )( void );
	typedef void ( *FnCommandCallback_t )( const CCommand &command );

	#define COMMAND_COMPLETION_MAXITEMS		64
	#define COMMAND_COMPLETION_ITEM_LENGTH	64

	//-----------------------------------------------------------------------------
	// Returns 0 to COMMAND_COMPLETION_MAXITEMS worth of completion strings
	//-----------------------------------------------------------------------------
	typedef int  ( *FnCommandCompletionCallback )( const char *partial, char commands[ COMMAND_COMPLETION_MAXITEMS ][ COMMAND_COMPLETION_ITEM_LENGTH ] );


	//-----------------------------------------------------------------------------
	// Interface version
	//-----------------------------------------------------------------------------
	class ICommandCallback
	{
	public:
		virtual void CommandCallback( const CCommand &command ) = 0;
	};

	class ICommandCompletionCallback
	{
	public:
		virtual int  CommandCompletionCallback( const char *pPartial, CUtlVector< CUtlString > &commands ) = 0;
	};

	//-----------------------------------------------------------------------------
	// Purpose: The base console invoked command/cvar interface
	//-----------------------------------------------------------------------------
	class ConCommandBase
	{
		friend class CCvar;
		friend class ConVar;
		friend class ConCommand;
		friend void ConVar_Register( int nCVarFlag, IConCommandBaseAccessor *pAccessor );
		friend void ConVar_PublishToVXConsole();

		// FIXME: Remove when ConVar changes are done
		friend class CDefaultCvar;

	public:
									ConCommandBase( void );
									ConCommandBase( const char *pName, const char *pHelpString = 0, 
										int flags = 0 );

		virtual						~ConCommandBase( void );

		virtual	bool				IsCommand( void ) const;

		// Check flag
		virtual bool				IsFlagSet( int flag ) const;
		// Set flag
		virtual void				AddFlags( int flags );

		// Return name of cvar
		virtual const char			*GetName( void ) const;

		// Return help text for cvar
		virtual const char			*GetHelpText( void ) const;

		// Deal with next pointer
		const ConCommandBase		*GetNext( void ) const;
		ConCommandBase				*GetNext( void );

		inline void SetNext(ConCommandBase *pBase)
		{
			m_pNext = pBase;
		}
		
		virtual bool				IsRegistered( void ) const;

		// Returns the DLL identifier
		virtual CVarDLLIdentifier_t	GetDLLIdentifier() const;

	protected:
		virtual void				Create( const char *pName, const char *pHelpString = 0, 
										int flags = 0 );

		// Used internally by OneTimeInit to initialize/shutdown
		virtual void				Init();
		void						Shutdown();

		// Internal copy routine ( uses new operator from correct module )
		char						*CopyString( const char *from );

	private:
		// Next ConVar in chain
		// Prior to register, it points to the next convar in the DLL.
		// Once registered, though, m_pNext is reset to point to the next
		// convar in the global list
		ConCommandBase				*m_pNext;

		// Has the cvar been added to the global list?
		bool						m_bRegistered;

		// Static data
		const char 					*m_pszName;
		const char 					*m_pszHelpString;
		
		// ConVar flags
		int							m_nFlags;

	protected:
		// ConVars add themselves to this list for the executable. 
		// Then ConVar_Register runs through  all the console variables 
		// and registers them into a global list stored in vstdlib.dll
		static ConCommandBase		*s_pConCommandBases;

		// ConVars in this executable use this 'global' to access values.
		static IConCommandBaseAccessor	*s_pAccessor;
	};


	//-----------------------------------------------------------------------------
	// Command tokenizer
	//-----------------------------------------------------------------------------
	class CCommand
	{
	public:
		CCommand();
		CCommand( int nArgC, const char **ppArgV );
		bool Tokenize( const char *pCommand, characterset_t *pBreakSet = NULL );
		void Reset();

		int ArgC() const;
		const char **ArgV() const;
		const char *ArgS() const;					// All args that occur after the 0th arg, in string form
		const char *GetCommandString() const;		// The entire command in string form, including the 0th arg
		const char *operator[]( int nIndex ) const;	// Gets at arguments
		const char *Arg( int nIndex ) const;		// Gets at arguments
		
		// Helper functions to parse arguments to commands.
		const char* FindArg( const char *pName ) const;
		int FindArgInt( const char *pName, int nDefaultVal ) const;

		static int MaxCommandLength();
		static characterset_t* DefaultBreakSet();

	private:
		enum
		{
			COMMAND_MAX_ARGC = 64,
			COMMAND_MAX_LENGTH = 512,
		};

		int		m_nArgc;
		int		m_nArgv0Size;
		char	m_pArgSBuffer[ COMMAND_MAX_LENGTH ];
		char	m_pArgvBuffer[ COMMAND_MAX_LENGTH ];
		const char*	m_ppArgv[ COMMAND_MAX_ARGC ];
	};

	inline int CCommand::MaxCommandLength()
	{
		return COMMAND_MAX_LENGTH - 1;
	}

	inline int CCommand::ArgC() const
	{
		return m_nArgc;
	}

	inline const char **CCommand::ArgV() const
	{
		return m_nArgc ? (const char**)m_ppArgv : NULL;
	}

	inline const char *CCommand::ArgS() const
	{
		return m_nArgv0Size ? &m_pArgSBuffer[m_nArgv0Size] : "";
	}

	inline const char *CCommand::GetCommandString() const
	{
		return m_nArgc ? m_pArgSBuffer : "";
	}

	inline const char *CCommand::Arg( int nIndex ) const
	{
		// FIXME: Many command handlers appear to not be particularly careful
		// about checking for valid argc range. For now, we're going to
		// do the extra check and return an empty string if it's out of range
		if ( nIndex < 0 || nIndex >= m_nArgc )
			return "";
		return m_ppArgv[nIndex];
	}

	inline const char *CCommand::operator[]( int nIndex ) const
	{
		return Arg( nIndex );
	}


	//-----------------------------------------------------------------------------
	// Purpose: The console invoked command
	//-----------------------------------------------------------------------------
	class ConCommand : public ConCommandBase
	{
	friend class CCvar;

	public:
		typedef ConCommandBase BaseClass;

		ConCommand( const char *pName, FnCommandCallbackV1_t callback, 
			const char *pHelpString = 0, int flags = 0, FnCommandCompletionCallback completionFunc = 0 );
		ConCommand( const char *pName, FnCommandCallback_t callback, 
			const char *pHelpString = 0, int flags = 0, FnCommandCompletionCallback completionFunc = 0 );
		ConCommand( const char *pName, ICommandCallback *pCallback, 
			const char *pHelpString = 0, int flags = 0, ICommandCompletionCallback *pCommandCompletionCallback = 0 );

		virtual ~ConCommand( void );

		virtual	bool IsCommand( void ) const;

		virtual int AutoCompleteSuggest( const char *partial, CUtlVector< CUtlString > &commands );

		virtual bool CanAutoComplete( void );

		// Invoke the function
		virtual void Dispatch( const CCommand &command );

	private:
		// NOTE: To maintain backward compat, we have to be very careful:
		// All public virtual methods must appear in the same order always
		// since engine code will be calling into this code, which *does not match*
		// in the mod code; it's using slightly different, but compatible versions
		// of this class. Also: Be very careful about adding new fields to this class.
		// Those fields will not exist in the version of this class that is instanced
		// in mod code.

		// Call this function when executing the command
		union
		{
			FnCommandCallbackV1_t m_fnCommandCallbackV1;
			FnCommandCallback_t m_fnCommandCallback;
			ICommandCallback *m_pCommandCallback; 
		};

		union
		{
			FnCommandCompletionCallback	m_fnCompletionCallback;
			ICommandCompletionCallback *m_pCommandCompletionCallback;
		};

		bool m_bHasCompletionCallback : 1;
		bool m_bUsingNewCommandCallback : 1;
		bool m_bUsingCommandCallbackInterface : 1;
	};


	//-----------------------------------------------------------------------------
	// Purpose: A console variable
	//-----------------------------------------------------------------------------
	class ConVar : public ConCommandBase, public IConVar
	{
	friend class CCvar;
	friend class ConVarRef;

	public:
		typedef ConCommandBase BaseClass;

									ConVar( const char *pName, const char *pDefaultValue, int flags = 0);

									ConVar( const char *pName, const char *pDefaultValue, int flags, 
										const char *pHelpString );
									ConVar( const char *pName, const char *pDefaultValue, int flags, 
										const char *pHelpString, bool bMin, float fMin, bool bMax, float fMax );
									ConVar( const char *pName, const char *pDefaultValue, int flags, 
										const char *pHelpString, FnChangeCallback_t callback );
									ConVar( const char *pName, const char *pDefaultValue, int flags, 
										const char *pHelpString, bool bMin, float fMin, bool bMax, float fMax,
										FnChangeCallback_t callback );

		virtual						~ConVar( void );

		virtual bool				IsFlagSet( int flag ) const;
		virtual const char*			GetHelpText( void ) const;
		virtual bool				IsRegistered( void ) const;
		virtual const char			*GetName( void ) const;
		virtual void				AddFlags( int flags );
		virtual	bool				IsCommand( void ) const;

		// Install a change callback (there shouldn't already be one....)
		void InstallChangeCallback( FnChangeCallback_t callback );

		// Retrieve value
		FORCEINLINE_CVAR float			GetFloat( void ) const;
		FORCEINLINE_CVAR int			GetInt( void ) const;
		FORCEINLINE_CVAR bool			GetBool() const {  return !!GetInt(); }
		FORCEINLINE_CVAR char const	   *GetString( void ) const;

		// Any function that allocates/frees memory needs to be virtual or else you'll have crashes
		//  from alloc/free across dll/exe boundaries.
		
		// These just call into the IConCommandBaseAccessor to check flags and set the var (which ends up calling InternalSetValue).
		virtual void				SetValue( const char *value );
		virtual void				SetValue( float value );
		virtual void				SetValue( int value );
		
		// Reset to default value
		void						Revert( void );

		// True if it has a min/max setting
		bool						GetMin( float& minVal ) const;
		bool						GetMax( float& maxVal ) const;
		const char					*GetDefault( void ) const;

	private:
		// Called by CCvar when the value of a var is changing.
		virtual void				InternalSetValue(const char *value);
		// For CVARs marked FCVAR_NEVER_AS_STRING
		virtual void				InternalSetFloatValue( float fNewValue );
		virtual void				InternalSetIntValue( int nValue );

		virtual bool				ClampValue( float& value );
		virtual void				ChangeStringValue( const char *tempVal, float flOldValue );

		virtual void				Create( const char *pName, const char *pDefaultValue, int flags = 0,
										const char *pHelpString = 0, bool bMin = false, float fMin = 0.0,
										bool bMax = false, float fMax = false, FnChangeCallback_t callback = 0 );

		// Used internally by OneTimeInit to initialize.
		virtual void				Init();

	private:

		// This either points to "this" or it points to the original declaration of a ConVar.
		// This allows ConVars to exist in separate modules, and they all use the first one to be declared.
		// m_pParent->m_pParent must equal m_pParent (ie: m_pParent must be the root, or original, ConVar).
		ConVar						*m_pParent;

		// Static data
		const char					*m_pszDefaultValue;
		
		// Value
		// Dynamically allocated
		char						*m_pszString;
		int							m_StringLength;

		// Values
		float						m_fValue;
		int							m_nValue;

		// Min/Max values
		bool						m_bHasMin;
		float						m_fMinVal;
		bool						m_bHasMax;
		float						m_fMaxVal;
		
		// Call this function when ConVar changes
		FnChangeCallback_t			m_fnChangeCallback;
	};


	//-----------------------------------------------------------------------------
	// Purpose: Return ConVar value as a float
	// Output : float
	//-----------------------------------------------------------------------------
	FORCEINLINE_CVAR float ConVar::GetFloat( void ) const
	{
		return m_pParent->m_fValue;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Return ConVar value as an int
	// Output : int
	//-----------------------------------------------------------------------------
	FORCEINLINE_CVAR int ConVar::GetInt( void ) const 
	{
		return m_pParent->m_nValue;
	}


	//-----------------------------------------------------------------------------
	// Purpose: Return ConVar value as a string, return "" for bogus string pointer, etc.
	// Output : const char *
	//-----------------------------------------------------------------------------
	FORCEINLINE_CVAR const char *ConVar::GetString( void ) const 
	{
		if ( m_nFlags & FCVAR_NEVER_AS_STRING )
			return "FCVAR_NEVER_AS_STRING";

		return ( m_pParent->m_pszString ) ? m_pParent->m_pszString : "";
	}


	//-----------------------------------------------------------------------------
	// Called by the framework to register ConCommands with the ICVar
	//-----------------------------------------------------------------------------
	void ConVar_Register( int nCVarFlag = 0, IConCommandBaseAccessor *pAccessor = NULL );
	void ConVar_Unregister( );


	//-----------------------------------------------------------------------------
	// Utility methods 
	//-----------------------------------------------------------------------------
	void ConVar_PrintFlags( const ConCommandBase *var );
	void ConVar_PrintDescription( const ConCommandBase *pVar );


	//-----------------------------------------------------------------------------
	// Purpose: Utility class to quickly allow ConCommands to call member methods
	//-----------------------------------------------------------------------------
	#ifdef _MSC_VER
	#pragma warning (disable : 4355 )
	#endif

	template< class T >
	class CConCommandMemberAccessor : public ConCommand, public ICommandCallback, public ICommandCompletionCallback
	{
		typedef ConCommand BaseClass;
		typedef void ( T::*FnMemberCommandCallback_t )( const CCommand &command );
		typedef int  ( T::*FnMemberCommandCompletionCallback_t )( const char *pPartial, CUtlVector< CUtlString > &commands );

	public:
		CConCommandMemberAccessor( T* pOwner, const char *pName, FnMemberCommandCallback_t callback, const char *pHelpString = 0,
			int flags = 0, FnMemberCommandCompletionCallback_t completionFunc = 0 ) :
			BaseClass( pName, this, pHelpString, flags, ( completionFunc != 0 ) ? this : NULL )
		{
			m_pOwner = pOwner;
			m_Func = callback;
			m_CompletionFunc = completionFunc;
		}

		~CConCommandMemberAccessor()
		{
			Shutdown();
		}

		void SetOwner( T* pOwner )
		{
			m_pOwner = pOwner;
		}

		virtual void CommandCallback( const CCommand &command )
		{
			Assert( m_pOwner && m_Func );
			(m_pOwner->*m_Func)( command );
		}

		virtual int  CommandCompletionCallback( const char *pPartial, CUtlVector< CUtlString > &commands )
		{
			Assert( m_pOwner && m_CompletionFunc );
			return (m_pOwner->*m_CompletionFunc)( pPartial, commands );
		}

	private:
		T* m_pOwner;
		FnMemberCommandCallback_t m_Func;
		FnMemberCommandCompletionCallback_t m_CompletionFunc;
	};

	#ifdef _MSC_VER
	#pragma warning ( default : 4355 )
	#endif

	//-----------------------------------------------------------------------------
	// Purpose: Utility macros to quicky generate a simple console command
	//-----------------------------------------------------------------------------
	#define CON_COMMAND( name, description ) \
	static void name( const CCommand &args ); \
	static ConCommand name##_command( #name, name, description ); \
	static void name( const CCommand &args )

	#define CON_COMMAND_F( name, description, flags ) \
	static void name( const CCommand &args ); \
	static ConCommand name##_command( #name, name, description, flags ); \
	static void name( const CCommand &args )

	#define CON_COMMAND_F_COMPLETION( name, description, flags, completion ) \
		static void name( const CCommand &args ); \
		static ConCommand name##_command( #name, name, description, flags, completion ); \
		static void name( const CCommand &args )

	#define CON_COMMAND_EXTERN( name, _funcname, description ) \
		void _funcname( const CCommand &args ); \
		static ConCommand name##_command( #name, _funcname, description ); \
		void _funcname( const CCommand &args )

	#define CON_COMMAND_EXTERN_F( name, _funcname, description, flags ) \
		void _funcname( const CCommand &args ); \
		static ConCommand name##_command( #name, _funcname, description, flags ); \
		void _funcname( const CCommand &args )

	#define CON_COMMAND_MEMBER_F( _thisclass, name, _funcname, description, flags ) \
		void _funcname( const CCommand &args );						\
		friend class CCommandMemberInitializer_##_funcname;			\
		class CCommandMemberInitializer_##_funcname					\
		{															\
		public:														\
			CCommandMemberInitializer_##_funcname() : m_ConCommandAccessor( NULL, name, &_thisclass::_funcname, description, flags )	\
			{														\
				m_ConCommandAccessor.SetOwner( GET_OUTER( _thisclass, m_##_funcname##_register ) );	\
			}														\
		private:													\
			CConCommandMemberAccessor< _thisclass > m_ConCommandAccessor;	\
		};															\
																	\
		CCommandMemberInitializer_##_funcname m_##_funcname##_register;
}

using namespace bob;
